<?xml version="1.0"?>

<!-- The contents of this file are subject to the Erlang Public License,
Version 1.1, (the "License"); you may not use this file except in compliance
with the License. You should have received a copy of the Erlang Public
License along with this software. If not, it can be retrieved via the world
wide web at http://plc.inf.elte.hu/erlang/

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is RefactorErl.

The Initial Developer of the Original Code is Eötvös Loránd University.
Portions created by Eötvös Loránd University are Copyright 2008, Eötvös
Loránd University. All Rights Reserved. -->


<!--
Formal description of the Erlang language as used by RefactorErl.

Authors: Tamas Nagy
         Laszlo Lovei
         Robert Kitlei
-->

<!DOCTYPE erlang-syntax [
          <!ELEMENT erlang-syntax (rule-class|token-class|
                                   lexical|pattern|keyword)*>
          <!ATTLIST erlang-syntax
                    start IDREF #REQUIRED
                    end   IDREF #REQUIRED>

<!-- Syntactical rules -->
          <!-- Group of rules by generated node class -->
          <!ELEMENT rule-class (ruleset)+ >
          <!ATTLIST rule-class
                    class   ID #REQUIRED
                    lexlink CDATA #REQUIRED>

          <!-- Token alternatives identified by `name' -->
          <!ELEMENT token-class (token)+ >
          <!ATTLIST token-class
                    name ID #REQUIRED>

          <!-- Production rules for the symbol given in `head' -->
          <!ELEMENT ruleset (rule|chain-rule)+ >
          <!ATTLIST ruleset
                    head ID #REQUIRED>

          <!-- A production rule that does not generate a node in the graph,
               just references the productions of the symbol `name' -->
          <!ELEMENT chain-rule EMPTY>
          <!ATTLIST chain-rule
                    name IDREF #REQUIRED>

          <!-- One production rule, generates a graph node -->
          <!-- The first attrib is mandatory, it shows the type or kind -->
          <!ELEMENT rule (attrib+,(symbol|token|repeat|optional)+) >

          <!-- The body is optional -->
          <!-- Optionals have to begin with a token or a repeat. -->
          <!ELEMENT optional ((symbol|token|repeat|optional)+) >

          <!-- Repetitions of the symbol with interspersed tokens -->
          <!ELEMENT repeat EMPTY>
          <!ATTLIST repeat
                    symbol    IDREF #REQUIRED
                    link      CDATA #REQUIRED
                    separator CDATA #REQUIRED>

          <!-- The next element in the rule is the symbol `name', it is linked
               under the new graph node with a tag `link' -->
          <!ELEMENT symbol EMPTY>
          <!ATTLIST symbol
                    name IDREF #REQUIRED
                    link CDATA #REQUIRED>

          <!-- The next element in the production is a token of type `type'
               (which can be a token class name or a token name). Its value is
               used as the value of graph node attribute `attr' (if
               given). -->
          <!ELEMENT token EMPTY>
          <!ATTLIST token
                    type IDREF #REQUIRED
                    attr CDATA #IMPLIED>

          <!-- A constant value for the graph node attribute `name'. -->
          <!ELEMENT attrib (#PCDATA)>
          <!ATTLIST attrib
                    name CDATA #REQUIRED
                    value CDATA #REQUIRED>

<!-- Lexical rules -->

          <!ELEMENT keywords (keyword)+>
          <!ATTLIST keywords>

          <!-- A textually given keyword. A lexical element of type `name' is
               generated by prepending `keyword-prefix' and appending
               `keyword-postfix'. -->
          <!ELEMENT keyword (#PCDATA)>
          <!ATTLIST keyword
                    name ID #REQUIRED>

          <!-- A lexical element that describes tokens of type `name'. -->
          <!ELEMENT lexical (match|rep|opt|branches|text|chars-of|chars-but)+ >
          <!ATTLIST lexical
                    name ID #REQUIRED>

          <!-- A pattern that can be referenced by `name'. -->
          <!ELEMENT pattern (match|rep|opt|branches|text|chars-of|chars-but)+ >
          <!ATTLIST pattern
                    name ID #REQUIRED>

          <!-- A reference to the pattern `name'. -->
          <!ELEMENT match EMPTY>
          <!ATTLIST match
                    name IDREF #REQUIRED>

          <!-- Selection between patterns -->
          <!ELEMENT branches (br)+>
          <!ELEMENT br  (match|rep|opt|branches|text|chars-of|chars-but)+ >

          <!-- Zero or more repetitions of a pattern -->
          <!ELEMENT rep (match|rep|opt|branches|text|chars-of|chars-but)+ >

          <!-- An optional pattern -->
          <!ELEMENT opt (match|rep|opt|branches|text|chars-of|chars-but)+ >

          <!-- Pattern of literal characters -->
          <!ELEMENT text      (#PCDATA|char)* >

          <!-- A character of a given set -->
          <!ELEMENT chars-of  (#PCDATA|char|range)* >

          <!-- A character that i not in the given set -->
          <!ELEMENT chars-but (#PCDATA|char|range)* >

          <!-- A character given by its decimal ASCII code) -->
          <!ELEMENT char EMPTY>
          <!ATTLIST char
                    code CDATA #REQUIRED>

          <!-- A character in the range starting at `from' and ending at
               `to' -->
          <!ELEMENT range (from,to)>
          <!ELEMENT from  (#PCDATA|char)* >
          <!ELEMENT to    (#PCDATA|char)* >
]>


<erlang-syntax start="Form" end="stop">


<!-- Top-level rules -->

  <rule-class class="form" lexlink="flex">
    <ruleset head="Form">
      <chain-rule name="Attribute" />
      <chain-rule name="Function" />
      <chain-rule name="EmptyForm" />
    </ruleset>

    <ruleset head="Attribute">
      <rule>
        <attrib name="type" value="attrib"/>
        <token type="minus"/>
        <token type="atom" attr="tag"/>
        <token type="op_paren"/>
        <repeat symbol="Expr" link="attr"
                separator="comma" />
        <token type="cl_paren"/>
        <token type="stop"/>
      </rule>
    </ruleset>

    <ruleset head="Function">
      <rule>
        <attrib name="type" value="func"/>
        <repeat symbol="FunClause" link="funcl"
                separator="semicol"/>
        <token type="stop"/>
      </rule>
    </ruleset>

    <!-- Note that `eol' tokens are removed during whitespace processing,
         only an empty file contains an `eol' token -->
    <ruleset head="EmptyForm">
      <rule>
        <attrib name="type" value="lex" />
        <attrib name="tag" value="empty" />
        <token type="eol" />
      </rule>
    </ruleset>
  </rule-class>


<!-- Clause rules -->

  <rule-class class="clause" lexlink="clex">
    <!-- Function clause -->
    <ruleset head="FunClause">
      <rule>
        <attrib name="kind" value="fundef"/>
        <symbol name="Atom" link="name"/>
        <token type="op_paren"/>
        <optional>
          <repeat symbol="Expr" link="pattern"
                  separator="comma"/>
        </optional>
        <token type="cl_paren"/>
        <optional>
          <token type="when"/>
          <symbol name="Guard_seq" link="guard"/>
        </optional>
        <token type="arrow"/>
        <repeat symbol="Expr" link="body"
                separator="comma"/>
      </rule>
    </ruleset>

    <!-- Exactly one expression -->
    <ruleset head="Expr_clause">
      <rule>
        <attrib name="kind" value="expr"/>
        <symbol name="Expr" link="body"/>
      </rule>
    </ruleset>

    <ruleset head="Expr_150_clause">
      <rule>
        <attrib name="kind" value="expr"/>
        <symbol name="Expr_150" link="body"/>
      </rule>
    </ruleset>

    <ruleset head="Expr_160_clause">
      <rule>
        <attrib name="kind" value="expr"/>
        <symbol name="Expr_160" link="body"/>
      </rule>
    </ruleset>

    <ruleset head="Expr_200_clause">
      <rule>
        <attrib name="kind" value="expr"/>
        <symbol name="Expr_200" link="body"/>
      </rule>
    </ruleset>

    <ruleset head="LCExpr_clause">
      <rule>
        <attrib name="kind" value="hexpr"/>
        <symbol name="Expr" link="body"/>
      </rule>
    </ruleset>

    <ruleset head="BCExpr_clause">
      <rule>
        <attrib name="kind" value="hexpr"/>
        <symbol name="Binary_expr" link="body"/>
      </rule>
    </ruleset>

    <ruleset head="PExpr_clause">
      <rule>
        <attrib name="kind" value="pexpr"/>
        <symbol name="Expr" link="pattern" />
      </rule>
    </ruleset>

    <ruleset head="PBinExpr_clause">
      <rule>
        <attrib name="kind" value="pexpr"/>
        <symbol name="Binary_expr" link="pattern"/>
      </rule>
    </ruleset>

    <!-- Comprehension tail part -->
    <ruleset head="Compr_clause">
      <rule>
        <attrib name="kind" value="compr"/>
        <repeat symbol="ComprExpr" link="body"
                separator="comma" />
      </rule>
    </ruleset>

    <!-- Simple expression list -->
    <ruleset head="Block_clause">
      <rule>
        <attrib name="kind" value="block"/>
        <repeat symbol="Expr" link="body"
                separator="comma"/>
      </rule>
    </ruleset>

    <!-- Clause that begins with a guard -->
    <ruleset head="Guarded_clause">
      <rule>
        <attrib name="kind" value="guard"/>
        <symbol name="Guard_seq" link="guard"/>
        <token type="arrow"/>
        <repeat symbol="Expr" link="body"
                separator="comma"/>
      </rule>
    </ruleset>

    <!-- Clause that begins with a timeout value -->
    <ruleset head="After_clause">
      <rule>
        <attrib name="kind" value="timeout"/>
        <symbol name="Expr" link="tmout"/>
        <token type="arrow"/>
        <repeat symbol="Expr" link="body"
                separator="comma"/>
      </rule>
    </ruleset>

    <!-- Clause that begins with exactly one pattern and an optional guard -->
    <ruleset head="Pattern_clause">
      <rule>
        <attrib name="kind" value="pattern"/>
        <symbol name="Expr" link="pattern"/>
        <optional>
          <token type="when"/>
          <symbol name="Guard_seq" link="guard"/>
        </optional>
        <token type="arrow"/>
        <repeat symbol="Expr" link="body"
                separator="comma"/>
      </rule>
    </ruleset>

    <!-- Clause that begins with multiple patterns and an optional guard -->
    <ruleset head="Funexpr_clause">
      <rule>
        <attrib name="kind" value="funexpr"/>
        <token type="op_paren"/>
        <optional>
          <repeat symbol="Expr" link="pattern"
                  separator="comma"/>
        </optional>
        <token type="cl_paren"/>
        <optional>
          <token type="when"/>
          <symbol name="Guard_seq" link="guard"/>
        </optional>
        <token type="arrow"/>
        <repeat symbol="Expr" link="body"
                separator="comma"/>
      </rule>
    </ruleset>
  </rule-class>


<!-- Expression rules -->

  <rule-class class="expr" lexlink="elex">
    <!-- Guard sequences -->
    <ruleset head="Guard_seq">
      <chain-rule name="Guard"/>
      
      <rule>
        <attrib name="kind" value="infix_expr"/>
        <symbol name="Guard" link="sub"/>
        <token type="semicol" attr="value"/>
        <symbol name="Guard_seq" link="sub"/>
      </rule>
    </ruleset>

    <ruleset head="Guard">
      <chain-rule name="Expr"/>

      <rule>
        <attrib name="kind" value="infix_expr"/>
        <symbol name="Expr" link="sub"/>
        <token type="comma" attr="value"/>
        <symbol name="Guard" link="sub"/>
      </rule>
    </ruleset>


  <!-- Expressions -->

    <!-- Catch -->
    <ruleset head="Expr">
      <rule>
        <attrib name="kind" value="catch_expr"/>
        <token type="catch"/>
        <symbol name="Expr_clause" link="exprcl"/>
      </rule>

      <chain-rule name="Expr_100"/>
    </ruleset>

    <!-- Pattern match, send -->
    <ruleset head="Expr_100">
      <rule>
        <attrib name="kind" value="match_expr"/>
        <symbol name="Expr_150" link="sub"/>
        <token type="equal"/>
        <symbol name="Expr_100" link="sub"/>
      </rule>
      <rule>
        <attrib name="kind" value="send_expr"/>
        <symbol name="Expr_150" link="sub"/>
        <token type="exclam"/>
        <symbol name="Expr_100" link="sub"/>
      </rule>
      <chain-rule name="Expr_150"/>
    </ruleset>

    <!-- orelse, andalso -->
    <ruleset head="Expr_150">
      <rule>
        <attrib name="kind" value="infix_expr"/>
        <symbol name="Expr_160_clause" link="exprcl"/>
        <token type="orelse" attr="value"/>
        <symbol name="Expr_150_clause" link="exprcl"/>
      </rule>
      <chain-rule name="Expr_160"/>
    </ruleset>

    <ruleset head="Expr_160">
      <rule>
        <attrib name="kind" value="infix_expr"/>
        <symbol name="Expr_200_clause" link="exprcl"/>
        <token type="andalso" attr="value"/>
        <symbol name="Expr_160_clause" link="exprcl"/>
      </rule>
      <chain-rule name="Expr_200"/>
    </ruleset>

    <!-- Comparison -->
    <ruleset head="Expr_200">
      <rule>
        <attrib name="kind" value="infix_expr"/>
        <symbol name="Expr_300" link="sub"/>
        <token type="Comp_op" attr="value"/>
        <symbol name="Expr_300" link="sub"/>
      </rule>

      <chain-rule name="Expr_300"/>
    </ruleset>

    <!-- List operators -->
    <ruleset head="Expr_300">
      <rule>
        <attrib name="kind" value="infix_expr"/>
        <symbol name="Expr_400" link="sub"/>
        <token type="List_op" attr="value"/>
        <symbol name="Expr_300" link="sub"/>
      </rule>

      <chain-rule name="Expr_400"/>
    </ruleset>

    <!-- Addition -->
    <ruleset head="Expr_400">
      <rule>
        <attrib name="kind" value="infix_expr"/>
        <symbol name="Expr_400" link="sub"/>
        <token type="Add_op" attr="value"/>
        <symbol name="Expr_500" link="sub"/>
      </rule>

      <chain-rule name="Expr_500"/>
    </ruleset>

    <!-- Multiplication -->
    <ruleset head="Expr_500">
      <rule>
        <attrib name="kind" value="infix_expr"/>
        <symbol name="Expr_500" link="sub"/>
        <token type="Mult_op" attr="value"/>
        <symbol name="Expr_600" link="sub"/>
      </rule>

      <chain-rule name="Expr_600"/>
    </ruleset>

    <!-- Prefix operators -->
    <ruleset head="Expr_600">
      <rule>
        <attrib name="kind" value="prefix_expr"/>
        <token type="Prefix_op" attr="value"/>
        <symbol name="Expr_700" link="sub"/>
      </rule>

      <chain-rule name="Expr_700"/>
    </ruleset>

    <!-- Function call, record expressions -->
    <ruleset head="Expr_700">
      <rule>
        <attrib name="kind" value="application"/>
        <symbol name="Expr_800" link="sub"/>
        <token type="op_paren"/>
        <optional>
          <repeat symbol="Expr" link="sub"
                  separator="comma"/>
        </optional>
        <token type="cl_paren"/>
      </rule>

      <chain-rule name="Record_expr" />
      <chain-rule name="Expr_800"/>
    </ruleset>

    <ruleset head="Record_expr">
      <rule>
        <attrib name="kind" value="record_index"/>
        <token type="hash"/>
        <symbol name="Atom" link="sub"/>
        <token type="dot"/>
        <symbol name="Atom" link="sub"/>
      </rule>

      <rule>
        <attrib name="kind" value="record_access"/>
        <symbol name="Expr_max" link="sub"/>
        <token type="hash"/>
        <symbol name="Atom" link="sub"/>
        <token type="dot"/>
        <symbol name="Atom" link="sub"/>
      </rule>

      <rule>
        <attrib name="kind" value="record_expr"/>
        <token type="hash"/>
        <symbol name="Atom" link="sub"/>
        <token type="op_brace"/>
        <optional>
          <repeat symbol="Record_field" link="sub"
                  separator="comma"/>
        </optional>
        <token type="cl_brace"/>
      </rule>

      <rule>
        <attrib name="kind" value="record_update"/>
        <symbol name="Expr_max" link="sub"/>
        <token type="hash"/>
        <symbol name="Atom" link="sub"/>
        <token type="op_brace"/>
        <optional>
          <repeat symbol="Record_field" link="sub"
                  separator="comma"/>
        </optional>
        <token type="cl_brace"/>
      </rule>
    </ruleset>

    <ruleset head="Record_field">
      <rule>
        <attrib name="kind" value="record_field"/>
        <symbol name="Atom" link="sub"/>
        <token type="equal"/>
        <symbol name="Expr" link="sub"/>
      </rule>
      <!-- This second rule supports `#rec{ _ = '_' }' syntax -->
      <rule>
        <attrib name="kind" value="record_field"/>
        <symbol name="Variable" link="sub"/>
        <token type="equal"/>
        <symbol name="Expr" link="sub"/>
      </rule>
    </ruleset>

    <!-- Module qualifier -->
    <ruleset head="Expr_800">
      <chain-rule name="Colon_qualifier"/>
      <chain-rule name="Expr_max"/>
    </ruleset>

    <ruleset head="Colon_qualifier">
      <rule>
        <attrib name="kind" value="infix_expr"/>
	<symbol name="Expr_max" link="sub"/>
        <token type="colon" attr="value"/>
        <symbol name="Expr_max" link="sub"/>
      </rule>
    </ruleset>

    <!-- Top-precedence expressions -->
    <ruleset head="Expr_max">
      <chain-rule name="Atomic"/>
      <chain-rule name="List_skel"/>
      <chain-rule name="List_compr"/>
      <chain-rule name="Binary_expr"/>
      <chain-rule name="Bin_compr"/>
      <chain-rule name="Tuple_skel"/>
      <chain-rule name="Paren_expr"/>
      <chain-rule name="Block_expr"/>
      <chain-rule name="If_expr"/>
      <chain-rule name="Case_expr"/>
      <chain-rule name="Receive_expr"/>
      <chain-rule name="Fun_expr"/>
      <chain-rule name="Try_expr" />
    </ruleset>

    <!-- Atomic expressions -->
    <ruleset head="Variable">
      <rule>
        <attrib name="kind" value="variable"/>
        <token type="variable" attr="value"/>
      </rule>
    </ruleset>

    <ruleset head="Atom">
      <rule>
        <attrib name="kind" value="atom"/>
        <token type="atom" attr="value"/>
      </rule>
    </ruleset>

    <ruleset head="Integer">
      <rule>
        <attrib name="kind" value="integer"/>
        <token type="integer" attr="value"/>
      </rule>
    </ruleset>

    <ruleset head="Atomic">
      <chain-rule name="Variable"/>
      <chain-rule name="Atom"/>
      <chain-rule name="Integer"/>
      <rule>
        <attrib name="kind" value="char"/>
        <token type="char" attr="value"/>
      </rule>

      <rule>
        <attrib name="kind" value="float"/>
        <token type="float" attr="value"/>
      </rule>

      <chain-rule name="String"/>
    </ruleset>

    <ruleset head="String">
      <rule>
        <attrib name="kind" value="string"/>
        <token type="string" attr="value"/>
      </rule>

      <rule>
        <attrib name="kind" value="mstring"/>
        <token type="string" attr="value"/>
        <symbol name="String" link="sub"/>
      </rule>
    </ruleset>

    <!-- List skeleton -->
    <ruleset head="List_skel">
      <rule>
        <attrib name="kind" value="cons"/>
        <token type="op_bracket"/>
        <optional>
          <symbol name="List_head" link="sub"/>
          <optional>
            <token type="vline"/>
            <symbol name="Expr" link="sub"/>
          </optional>
        </optional>
        <token type="cl_bracket"/>
      </rule>
    </ruleset>

    <ruleset head="List_head">
      <rule>
        <attrib name="kind" value="list"/>
        <repeat symbol="Expr" link="sub"
                separator="comma"/>
      </rule>
    </ruleset>

    <!-- Binary expression -->
    <ruleset head="Binary_expr">
      <rule>
        <attrib name="kind" value="binary"/>
        <token type="dbl_less"/>
        <optional>
          <repeat symbol="Bin_element" link="sub"
                  separator="comma"/>
        </optional>
        <token type="dbl_greater"/>
      </rule>
    </ruleset>

    <ruleset head="Bin_element">
      <rule>
        <attrib name="kind" value="binary_field"/>
        <symbol name="Bin_base" link="sub"/>
        <optional>
          <token type="slash"/>
          <repeat symbol="Bit_type" link="sub"
                  separator="minus"/>
        </optional>
      </rule>
    </ruleset>

    <ruleset head="Bin_base">
      <chain-rule name="Bit_expr"/>

      <rule>
        <attrib name="kind" value="size_qualifier"/>
        <symbol name="Bit_expr" link="sub"/>
        <token type="colon"/>
        <symbol name="Expr_max" link="sub"/>
      </rule>
    </ruleset>

    <ruleset head="Bit_expr">
      <chain-rule name="Expr_max"/>

      <rule>
        <attrib name="kind" value="prefix_bit_expr"/>
        <token type="Prefix_op" attr="value"/>
        <symbol name="Expr_max" link="sub"/>
      </rule>
    </ruleset>

    <ruleset head="Bit_type">
      <chain-rule name="Atom"/>

      <rule>
        <attrib name="kind" value="bit_size_expr"/>
        <symbol name="Atom" link="sub"/>
        <token type="colon"/>
        <token type="integer" attr="value"/>
      </rule>
    </ruleset>


    <!-- List and binary comprehension -->
    <ruleset head="List_compr">
      <rule>
        <attrib name="kind" value="list_comp"/>
        <token type="op_bracket"/>
        <symbol name="LCExpr_clause" link="exprcl"/>
        <token type="dbl_vline"/>
        <symbol name="Compr_clause" link="exprcl"/>
        <token type="cl_bracket"/>
      </rule>
    </ruleset>

    <ruleset head="Bin_compr">
      <rule>
        <attrib name="kind" value="bin_comp"/>
        <token type="dbl_less"/>
        <symbol name="BCExpr_clause" link="exprcl"/>
        <token type="dbl_vline"/>
        <symbol name="Compr_clause" link="exprcl"/>
        <token type="dbl_greater"/>
      </rule>
    </ruleset>

    <ruleset head="ComprExpr">
      <chain-rule name="FilterExpr"/>
      <chain-rule name="List_generator"/>
      <chain-rule name="Binary_generator"/>
    </ruleset>

    <ruleset head="FilterExpr">
      <rule>
        <attrib name="kind" value="filter"/>
        <symbol name="Expr_clause" link="exprcl" />
      </rule>
    </ruleset>

    <ruleset head="List_generator">
      <rule>
        <attrib name="kind" value="list_gen"/>
        <symbol name="PExpr_clause" link="exprcl"/>
        <token type="backarrow"/>
        <symbol name="Expr_clause" link="exprcl"/>
      </rule>
    </ruleset>

    <ruleset head="Binary_generator">
      <rule>
        <attrib name="kind" value="binary_gen"/>
        <symbol name="PBinExpr_clause" link="exprcl"/>
        <token type="backbinarrow"/>
        <symbol name="Expr_clause" link="exprcl"/>
      </rule>
    </ruleset>

    <!-- Tuple skeleton -->
    <ruleset head="Tuple_skel">
      <rule>
        <attrib name="kind" value="tuple"/>
        <token type="op_brace"/>
        <optional>
          <repeat symbol="Expr" link="sub"
                  separator="comma"/>
        </optional>
        <token type="cl_brace"/>
      </rule>
    </ruleset>

    <!-- Parentheses -->
    <ruleset head="Paren_expr">
      <rule>
        <attrib name="kind" value="parenthesis"/>
        <token type="op_paren"/>
        <symbol name="Expr" link="sub"/>
        <token type="cl_paren"/>
      </rule>
    </ruleset>

    <!-- begin ... end -->
    <ruleset head="Block_expr">
      <rule>
        <attrib name="kind" value="block_expr"/>
        <token type="begin"/>
        <symbol name="Block_clause" link="exprcl"/>
        <token type="end"/>
      </rule>
    </ruleset>


    <!-- if -->
    <ruleset head="If_expr">
      <rule>
        <attrib name="kind" value="if_expr"/>
        <token type="if"/>
        <repeat symbol="Guarded_clause" link="exprcl"
                separator="semicol"/>
        <token type="end"/>
      </rule>
    </ruleset>

    <!-- case -->
    <ruleset head="Case_expr">
      <rule>
        <attrib name="kind" value="case_expr"/>
        <token type="case"/>
        <symbol name="Expr_clause" link="headcl"/>
        <token type="of"/>
        <repeat symbol="Pattern_clause" link="exprcl"
                separator="semicol"/>
        <token type="end"/>
      </rule>
    </ruleset>

    <!-- receive -->
    <ruleset head="Receive_expr">
      <rule>
        <attrib name="kind" value="receive_expr"/>
        <token type="receive"/>
        <optional>
          <repeat symbol="Pattern_clause" link="exprcl"
                  separator="semicol"/>
        </optional>
        <optional>
          <token type="after"/>
          <symbol name="After_clause" link="aftercl"/>
        </optional>
        <token type="end"/>
      </rule>
    </ruleset>

    <!-- fun -->
    <ruleset head="Fun_expr">
      <rule>
        <attrib name="kind" value="fun_expr"/>
        <token type="fun"/>
        <repeat symbol="Funexpr_clause" link="exprcl"
                separator="semicol"/>
        <token type="end"/>
      </rule>

      <rule>
        <attrib name="kind" value="implicit_fun"/>
        <token type="fun"/>
        <symbol name="Module_qualifier" link="sub" />
        <token type="slash"/>
        <symbol name="Integer" link="sub"/>
      </rule>
    </ruleset>

    <ruleset head="Module_qualifier">
      <chain-rule name="Atom" />
      <rule>
        <attrib name="kind" value="infix_expr"/>
        <symbol name="Atom" link="sub" />
        <token type="colon" attr="value"/>
        <symbol name="Atom" link="sub"/>
      </rule>
    </ruleset>

    <!-- try -->
    <ruleset head="Try_expr">
      <rule>
        <attrib name="kind" value="try_expr"/>
        <token type="try"/>
        <symbol name="Block_clause" link="headcl"/>
        <optional>
          <token type="of"/>
          <repeat symbol="Pattern_clause" link="exprcl"
                  separator="semicol"/>
        </optional>
        <optional>
          <token type="catch"/>
          <repeat symbol="Pattern_clause" link="catchcl"
                  separator="semicol"/>
        </optional>
        <optional>
          <token type="after"/>
          <symbol name="Block_clause" link="aftercl"/>
        </optional>
        <token type="end"/>
      </rule>
    </ruleset>

  </rule-class>


<!-- Lexical rules -->
  <token-class name="Comp_op">
    <token type="dbl_eq"/>
    <token type="slasheq"/>
    <token type="eqless"/>
    <token type="less"/>
    <token type="greatereq"/>
    <token type="greater"/>
    <token type="eqcoleq"/>
    <token type="eqslasheq"/>
  </token-class>

  <token-class name="Prefix_op">
    <token type="plus"/>
    <token type="minus"/>
    <token type="bnot"/>
    <token type="not"/>
  </token-class>

  <token-class name="Mult_op">
    <token type="slash"/>
    <token type="star"/>
    <token type="div"/>
    <token type="rem"/>
    <token type="band"/>
    <token type="and"/>
  </token-class>

  <token-class name="Add_op">
    <token type="plus"/>
    <token type="minus"/>
    <token type="bor"/>
    <token type="bxor"/>
    <token type="bsl"/>
    <token type="bsr"/>
    <token type="or"/>
    <token type="xor"/>
  </token-class>

  <token-class name="List_op">
    <token type="dbl_plus"/>
    <token type="dbl_minus"/>
  </token-class>


  <!-- Textual keywords -->
  <keyword name="after"  >after</keyword>
  <keyword name="and"    >and</keyword>
  <keyword name="andalso">andalso</keyword>
  <keyword name="band"   >band</keyword>
  <keyword name="begin"  >begin</keyword>
  <keyword name="bnot"   >bnot</keyword>
  <keyword name="bor"    >bor</keyword>
  <keyword name="bsl"    >bsl</keyword>
  <keyword name="bsr"    >bsr</keyword>
  <keyword name="bxor"   >bxor</keyword>
  <keyword name="case"   >case</keyword>
  <keyword name="catch"  >catch</keyword>
  <keyword name="div"    >div</keyword>
  <keyword name="end"    >end</keyword>
  <keyword name="fun"    >fun</keyword>
  <keyword name="if"     >if</keyword>
  <keyword name="not"    >not</keyword>
  <keyword name="of"     >of</keyword>
  <keyword name="or"     >or</keyword>
  <keyword name="orelse" >orelse</keyword>
  <keyword name="receive">receive</keyword>
  <keyword name="rem"    >rem</keyword>
  <keyword name="try"    >try</keyword>
  <keyword name="when"   >when</keyword>
  <keyword name="xor"    >xor</keyword>

  <!-- Separators -->
  <keyword name="dot"        >.</keyword>
  <keyword name="op_paren"   >(</keyword>
  <keyword name="cl_paren"   >)</keyword>
  <keyword name="op_brace"   >{</keyword>
  <keyword name="cl_brace"   >}</keyword>
  <keyword name="op_bracket" >[</keyword>
  <keyword name="cl_bracket" >]</keyword>
  <keyword name="dbl_less"   >&lt;&lt;</keyword>
  <keyword name="dbl_greater">&gt;&gt;</keyword>
  <keyword name="comma"      >,</keyword>
  <keyword name="semicol"    >;</keyword>
  <keyword name="colon"      >:</keyword>
  <keyword name="arrow"      >-&gt;</keyword>
  <keyword name="vline"      >|</keyword>
  <keyword name="dbl_vline"  >||</keyword>
  <keyword name="hash"       >#</keyword>

  <!-- Operators -->
  <keyword name="equal"      >=</keyword>
  <keyword name="plus"       >+</keyword>
  <keyword name="minus"      >-</keyword>
  <keyword name="star"       >*</keyword>
  <keyword name="slash"      >/</keyword>
  <keyword name="exclam"     >!</keyword>
  <keyword name="dbl_plus"   >++</keyword>
  <keyword name="dbl_minus"  >--</keyword>
  <keyword name="dbl_eq"     >==</keyword>
  <keyword name="slasheq"    >/=</keyword>
  <keyword name="eqcoleq"    >=:=</keyword>
  <keyword name="eqslasheq"  >=/=</keyword>
  <keyword name="less"       >&lt;</keyword>
  <keyword name="greater"    >&gt;</keyword>
  <keyword name="eqless"     >=&lt;</keyword>
  <keyword name="greatereq"  >&gt;=</keyword>
  <keyword name="backarrow"  >&lt;-</keyword>
  <keyword name="questionm"  >?</keyword>

  <keyword name="backbinarrow">&lt;=</keyword>

  <lexical name="ws">
    <match name="WS"/>
    <rep><match name="WS"/></rep>
  </lexical>

  <lexical name="eol">
    <rep><match name="WS"/></rep>
    <match name="EOL" />
  </lexical>

  <lexical name="stop">
    <text>.</text>
    <branches>
      <br>
        <match name="EOL" />
      </br>
      <br>
        <match name="WS" />
        <rep><match name="WS" /></rep>
        <opt>
          <match name="EOL" />
        </opt>
      </br>
    </branches>
  </lexical>

  <lexical name="atom">
    <branches>
      <br>
        <match name="Lower"/>
        <rep>
          <match name="Namechar"/>
        </rep>
      </br>
      <br>
        <text>'</text>
        <rep>
          <branches>
            <br><chars-but><char code="10" />\'</chars-but></br>
            <br><match name="Escape" /></br>
          </branches>
        </rep>
        <text>'</text>
      </br>
    </branches>
  </lexical>

  <lexical name="variable">
    <branches>
      <br><match name="Upper" /></br>
      <br><text>_</text></br>
    </branches>
    <rep>
      <match name="Namechar" />
    </rep>
  </lexical>

  <lexical name="string">
    <text>&quot;</text>
    <rep>
      <branches>
        <br><chars-but>&quot;\</chars-but></br>
        <br><match name="Escape"/></br>
      </branches>
    </rep>
    <text>&quot;</text>
  </lexical>

  <lexical name="integer">
    <branches>
      <br>
        <opt>
          <chars-of><range><from>2</from><to>9</to></range></chars-of>
          <text>#</text>
        </opt>
        <match name="Digit"/>
        <rep>
          <match name="Digit"/>
        </rep>
      </br>
      <br>
        <chars-of><range><from>1</from><to>3</to></range></chars-of>
        <chars-of><range><from>0</from><to>9</to></range></chars-of>
        <text>#</text>
        <chars-of>
          <range><from>0</from><to>9</to></range>
          <range><from>a</from><to>z</to></range>
          <range><from>A</from><to>Z</to></range>
        </chars-of>
        <rep>
          <chars-of>
            <range><from>0</from><to>9</to></range>
            <range><from>a</from><to>z</to></range>
            <range><from>A</from><to>Z</to></range>
          </chars-of>
        </rep>
      </br>
    </branches>
  </lexical>

  <lexical name="float">
    <match name="Digit"/>
    <rep>
      <match name="Digit"/>
    </rep>
    <text>.</text>
    <match name="Digit"/>
    <rep>
      <match name="Digit"/>
    </rep>
  </lexical>

  <lexical name="char">
    <text>$</text>
    <branches>
      <br><chars-but>\<char code="10"></char></chars-but></br>
      <br><match name="Escape" /></br>
    </branches>
  </lexical>

  <pattern name="WS">
    <chars-of>
      <char code="32"/>
      <char code="9"/>
    </chars-of>
  </pattern>

  <pattern name="EOL">
    <opt>
      <text>%</text>
      <rep>
        <chars-but><char code="10"/><char code="13"/></chars-but>
      </rep>
    </opt>
    <branches>
      <br><text><char code="10"/></text></br>
      <br><text><char code="13"/></text></br>
      <br><text><char code="13"/><char code="10"/></text></br>
      <br><!-- This is an incorrect line end -->
        <text><char code="10"/><char code="13"/></text></br>
    </branches>
  </pattern>

  <pattern name="Upper">
    <chars-of>
      <range><from>A</from><to>Z</to></range>
      <range><from><char code="192"/></from><to><char code="214"/></to></range>
      <range><from><char code="216"/></from><to><char code="222"/></to></range>
    </chars-of>
  </pattern>

  <pattern name="Lower">
    <chars-of>
      <range><from>a</from><to>z</to></range>
      <range><from><char code="223"/></from><to><char code="246"/></to></range>
      <range><from><char code="248"/></from><to><char code="255"/></to></range>
    </chars-of>
  </pattern>

  <pattern name="Digit">
    <chars-of><range><from>0</from><to>9</to></range></chars-of>
  </pattern>

  <pattern name="Octal">
    <chars-of><range><from>0</from><to>7</to></range></chars-of>
  </pattern>

  <pattern name="Escape">
    <text>\</text>
    <branches>
      <br>
        <chars-but><range><from>0</from><to>7</to></range></chars-but>
      </br>
      <br>
        <match name="Octal"/>
        <opt>
          <match name="Octal"/>
          <opt><match name="Octal"/></opt>
        </opt>
      </br>
      <br>
        <text>^</text>
        <chars-of><range><from>A</from><to>Z</to></range></chars-of>
      </br>
    </branches>
  </pattern>

  <pattern name="Namechar">
    <branches>
      <br><match name="Digit" /></br>
      <br><match name="Lower" /></br>
      <br><match name="Upper" /></br>
      <br><chars-of>_@</chars-of></br>
    </branches>
  </pattern>

</erlang-syntax>
