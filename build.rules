%%% This file has -*- Erlang -*- syntax.

%% ===========================================================================
%% Configuration

%% These variables are used to generate the release file and boot script to
%% start RefactorErl. The startup script relies on the release name, so don't
%% change that. The version number should be updated when necessary.
RELEASE = "refactorerl".
VERSION = "0.7".

%% Flags used by the compiler
ErlFlags = [debug_info].


%% ===========================================================================
%% Description of targets
%%
%% tool    -- builds everything that is necessary to run the tool
%%              Included targets: builder
%%                                source
%%
%% doc     -- builds the API documentation
%%              Included targets: builder
%%                                source
%%
%% clean   -- removes every file that is generated by the build
%%
%% source  -- creates the complete source code, mainly by generating files
%%            which are to be generated
%%              Included targets: builder
%%
%% builder -- builds programs that are parts of the build system


%% ===========================================================================
%% Description of global rules
%%
%% erl  -- compiles and loads Erlang modules
%%           Input files: specified by #source.files
%%           Output dir: `ebin'
%%
%% yrl  -- generates Erlang code using yecc
%%           Input files: specified by #source.files
%%           Output dir: `src'
%%
%% xrl  -- generates Erlang code using leex
%%           Input files: specified by #source.files
%%           Output dir: `src'
%%
%% lex  -- generates a lexical analyser table using refgen_scanc
%%           Input files: specified by #source.files
%%           Output dir: `lex'
%%
%% app  -- generates application descriptors from .appspec files
%%           Input files: specified by #source.files
%%           Output dir: `ebin'
%%
%% rel  -- generates RELEASE.rel
%%           Input files: lib/*/ebin/*.app
%%           Output file: RELEASE.rel
%%
%% boot -- generates a boot script from a release file
%%           Input files: specified by #source.files (*.rel)
%%           Output dir: same as source
%%
%% doc  -- generated EDoc documentation for an application
%%           Input files: specified by #source.files (*.app)
%%           Output dir: `doc'


%% ===========================================================================
%% Rules and targets

#rule{name   = erl,
      output = join("ebin", basename(File, ".erl")++".beam"),
      action =
        begin
            {ok, _} = compile:file(File, [report,
                                          {outdir, join(Dir, "ebin")},
                                          {i, join(Dir, "include")} |
                                          ErlFlags]),
            code:purge(list_to_atom(basename(File, ".erl"))),
            code:load_abs(join([Dir, "ebin", basename(File, ".erl")]))
        end,
      deps    =
        begin
            Path = [join(Dir, "include") | [Inc || {i, Inc} <- ErlFlags]],
            [{file, F} || F <- referl_gen_build:erl_includes(File, Path)]
        end}.

#rule{name   = yrl,
      output = join("src", basename(File,".yrl")++".erl"),
      action = {ok,_}=yecc:file(File, [verbose]),
      deps   = [{mod, yecc}]}.

#rule{name   = xrl,
      output = join("src", basename(File,".xrl")++".erl"),
      action = {ok,_}=leex:file(File, [verbose]),
      deps   = [{mod, leex}]}.

#rule{name   = lex,
      output = join("priv", basename(File)++".tab"),
      action = ok=refgen_scanc:file(
                    File,
                    [{output, join([Dir, "priv", basename(File)++".tab"])}]),
      deps   = [{mod, refgen_scanc}]}.

#rule{name   = app,
      output = join("ebin", basename(File, ".appspec")++".app"),
      action = %% This could be put into a module.
        begin
            {ok, Spec} = file:consult(File),
            App =
                {application, list_to_atom(basename(Dir)),
                 lists:map(
                   fun
                       ({modSrc, Mods}) ->
                           {modules,
                            [list_to_atom(basename(Src, ".erl")) ||
                                Src <- lists:append(
                                         [filelib:wildcard(
                                            join(dirname(File), Mod)) ||
                                             Mod <- Mods])]};
                       (Other) -> Other
                   end,
                   Spec)},
            ok = file:write_file(
                   join([Dir, "ebin", basename(File, ".appspec")++".app"]),
                   [io_lib:print(App), ".\n"])
        end}.

#rule{name   = rel,
      output = RELEASE ++ ".rel",
      action = %% This could also be put into a module.
        begin
            Apps = [list_to_atom(basename(App, ".app")) ||
                       App <- filelib:wildcard(
                                join([Dir, "lib", "*", "ebin", "*.app"]))],
            AllApps =
                [begin
                     application:load(App),
                     {ok, Deps} = application:get_key(App, applications),
                     [App | Deps]
                 end || App <- Apps],
            AppInfo =
                [begin
                     application:load(App),
                     {ok, Vsn} = application:get_key(App, vsn),
                     {App, Vsn}
                 end || App <- lists:usort(lists:flatten(AllApps))],
            Rel = {release,
                   {RELEASE, VERSION},
                   {erts, erlang:system_info(version)},
                   AppInfo},
            ok = file:write_file(join(Dir, RELEASE ++ ".rel"),
                                 [io_lib:print(Rel), ".\n"])
        end,
      deps   = [{file, App} ||
                   App <- filelib:wildcard(
                            join([Dir, "lib", "*", "ebin", "*.app"]))]}.

#rule{name   = boot,
      output = join(dirname(File), basename(File, ".rel")++".boot"),
      action = ok=systools:make_script(
                    join(dirname(File), basename(File, ".rel")),
                    [no_module_tests])}.

#rule{name   = doc,
      output = [join("doc", "index.html") |
                [join("doc", basename(F, ".erl") ++ ".html") ||
                    F <- filelib:wildcard(join([Dir, "src", "*.erl"]))]],
      action = try edoc:application(list_to_atom(basename(File, ".app"))) of
                   ok -> ok
               catch
                   exit:error -> erlang:error(edoc_error)
               end,
      deps   = [{file, join([Dir, "doc", "overview.edoc"])} |
                [{file, F} || F<-filelib:wildcard(join([Dir,"src","*.erl"]))]]}.



#target{name=source,
        rules=[#invoke{target=builder}]}.

#target{name=tool,
        rules=[#invoke{target=source}]}.

#target{name=doc,
        rules=[#invoke{target=source}]}.

#invoke{dir="lib"}.

#target{name=tool,
        rules=[#source{rule=rel},
               #source{files="refactorerl.rel", rule=boot}]}.

#target{name=clean,
        rules=[#apply{files=["refactorerl.*", "build.deps"],
                      action=file:delete(File)},
               exit(clear_deps)]}.
