<?xml version="1.0"?>

<!--
The contents of this file are subject to the Mozilla Public License Version
1.1 (the "License"); you may not use this file except in compliance with the
License. You may obtain a copy of the License at http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is RefactorErl.

The Initial Developer of the Original Code is Eötvös Loránd University.
Portions created by Eötvös Loránd University are Copyright 2008, Eötvös
Loránd University. All Rights Reserved.

Contributor(s): ______________________________________.


Formal description of the Erlang language as used by RefactorErl.
Authors: Tamas Nagy
         Laszlo Lovei

-->

<!DOCTYPE erlang-syntax [
          <!ELEMENT erlang-syntax (ruleset|token-class|lexical|pattern
                                  |keyword|keyword-prefix|keyword-postfix)*>
          <!ATTLIST erlang-syntax
                    start IDREF #REQUIRED
                    end   IDREF #REQUIRED>

<!-- Syntactical rules -->

          <!-- Production rules for the symbol given in `head' -->
          <!ELEMENT ruleset (rule|copy-rule)+ >
          <!ATTLIST ruleset
                    head ID #REQUIRED>

          <!-- Token alternatives identified by `name' -->
          <!ELEMENT token-class (token)+ >
          <!ATTLIST token-class
                    name ID #REQUIRED>

          <!-- A production rule that does not generate a node in the graph,
               just references the productions of the symbol `name' -->
          <!ELEMENT copy-rule EMPTY>
          <!ATTLIST copy-rule
                    name IDREF #REQUIRED>

          <!-- One production rule, generates a graph node of class `class' -->
          <!ELEMENT rule (attrib|symbol|token|repeat|optional)+ >
          <!ATTLIST rule
                    class CDATA #REQUIRED>

          <!-- The body is optional -->
          <!ELEMENT optional (attrib|symbol|token|repeat|optional)+ >

          <!-- Zero or more repetitions of the body -->
          <!ELEMENT repeat   (attrib|symbol|token|repeat|optional)+ >

          <!-- The next element in the rule is the symbol `name', it is linked
               under the new graph node with a tag `link' -->
          <!ELEMENT symbol EMPTY>
          <!ATTLIST symbol
                    name IDREF #REQUIRED
                    link CDATA #REQUIRED>

          <!-- The next element in the production is a token of type `type'
               (which can be a token class name or a token name). Its value is
               used as the value of graph node attribute `attr' (if
               given). -->
          <!ELEMENT token EMPTY>
          <!ATTLIST token
                    type IDREF #REQUIRED
                    attr CDATA #IMPLIED>

          <!-- A constant value for the graph node attribute `name'. -->
          <!ELEMENT attrib (#PCDATA)>
          <!ATTLIST attrib
                    name CDATA #REQUIRED>

<!-- Lexical rules -->

          <!-- A textually given keyword. A lexical element of type `name' is
               generated by prepending `keyword-prefix' and appending
               `keyword-postfix'. -->
          <!ELEMENT keyword (#PCDATA)>
          <!ATTLIST keyword
                    name ID #REQUIRED>
          <!ELEMENT keyword-prefix
                    (match|rep|opt|branches|text|chars-of|chars-but)+>
          <!ELEMENT keyword-postfix
                    (match|rep|opt|branches|text|chars-of|chars-but)+>

          <!-- A lexical element that describes tokens of type `name'. -->
          <!ELEMENT lexical (match|rep|opt|branches|text|chars-of|chars-but)+ >
          <!ATTLIST lexical
                    name ID #REQUIRED>

          <!-- A pattern that can be referenced by `name'. -->
          <!ELEMENT pattern (match|rep|opt|branches|text|chars-of|chars-but)+ >
          <!ATTLIST pattern
                    name ID #REQUIRED>

          <!-- A reference to the pattern `name'. -->
          <!ELEMENT match EMPTY>
          <!ATTLIST match
                    name IDREF #REQUIRED>

          <!-- Selection between patterns -->
          <!ELEMENT branches (br)+>
          <!ELEMENT br  (match|rep|opt|branches|text|chars-of|chars-but)+ >

          <!-- Zero or more repetitions of a pattern -->
          <!ELEMENT rep (match|rep|opt|branches|text|chars-of|chars-but)+ >

          <!-- An optional pattern -->
          <!ELEMENT opt (match|rep|opt|branches|text|chars-of|chars-but)+ >

          <!-- Pattern of literal characters -->
          <!ELEMENT text      (#PCDATA|char)* >

          <!-- A character of a given set -->
          <!ELEMENT chars-of  (#PCDATA|char|range)* >

          <!-- A character that i not in the given set -->
          <!ELEMENT chars-but (#PCDATA|char|range)* >

          <!-- A character given by its decimal ASCII code) -->
          <!ELEMENT char EMPTY>
          <!ATTLIST char
                    code CDATA #REQUIRED>

          <!-- A character in the range starting at `from' and ending at
               `to' -->
          <!ELEMENT range (from,to)>
          <!ELEMENT from  (#PCDATA|char)* >
          <!ELEMENT to    (#PCDATA|char)* >
]>


<erlang-syntax start="Form" end="stop">


<!-- Top-level rules -->

  <ruleset head="Form">
    <copy-rule name="Attribute" />
    <copy-rule name="Function" />
  </ruleset>

  <!-- The `export' attribute is produced incorrectly by this rule, because
       infix operators are produced instead of module qualifiers -->
  <ruleset head="Attribute">
    <rule class="form">
      <attrib name="type">attrib</attrib>
      <token type="minus"/>
      <token type="atom" attr="tag"/>
      <token type="op_paren"/>
      <symbol name="Expr" link="attr"/>
      <repeat>
        <token type="comma"/>
        <symbol name="Expr" link="attr"/>
      </repeat>
      <token type="cl_paren"/>
      <token type="stop"/>
    </rule>
  </ruleset>

  <ruleset head="Function">
    <rule class="form">
      <attrib name="type">func</attrib>
      <symbol name="FunClause" link="funcl"/>
      <repeat>
        <token type="semicol"/>
        <symbol name="FunClause" link="funcl"/>
      </repeat>
      <token type="stop"/>
    </rule>
  </ruleset>
  
  <!-- Function clause -->

  <ruleset head="FunClause">
    <rule class="clause">
      <attrib name="type">funcl</attrib>
      <symbol name="Atom" link="name"/>
      <token type="op_paren"/>
      <optional>
        <symbol name="Expr" link="pattern"/>
        <repeat>
          <token type="comma"/>
          <symbol name="Expr" link="pattern"/>
        </repeat>
      </optional>
      <token type="cl_paren"/>
      <optional>
        <token type="when"/>
        <symbol name="Guard_seq" link="guard"/>
      </optional>
      <token type="arrow"/>
      <symbol name="Expr" link="body"/>
      <repeat>
        <token type="comma"/>
        <symbol name="Expr" link="body"/>
      </repeat>
    </rule>
  </ruleset>

  <!-- Guard sequences -->
  <ruleset head="Guard_seq">
    <copy-rule name="Guard"/>
    
    <rule class="expr">
      <attrib name="kind">disjunction</attrib>
      <symbol name="Guard" link="sub"/>
      <token type="semicol"/>
      <symbol name="Guard_seq" link="sub"/>
    </rule>
  </ruleset>

  <ruleset head="Guard">
    <copy-rule name="Expr"/>

    <rule class="expr">
      <attrib name="kind">conjunction</attrib>
      <symbol name="Expr" link="sub"/>
      <token type="comma"/>
      <symbol name="Guard" link="sub"/>
    </rule>
  </ruleset>


<!-- Expressions -->


  <!-- Catch -->
  <ruleset head="Expr">
    <rule class="expr">
      <attrib name="kind">catch_expr</attrib>
      <token type="catch"/>
      <symbol name="Catch_block" link="exprcl"/>
    </rule>

    <copy-rule name="Expr_100"/>
  </ruleset>

  <ruleset head="Catch_block">
    <rule class="clause">
      <attrib name="type">block</attrib>
      <symbol name="Expr" link="body"/>
    </rule>
  </ruleset>

  <!-- Pattern match, send -->
  <ruleset head="Expr_100">
    <rule class="expr">
      <attrib name="kind">match_expr</attrib>
      <symbol name="Expr_150" link="sub"/>
      <token type="equal"/>
      <symbol name="Expr_100" link="sub"/>
    </rule>
    <rule class="expr">
      <attrib name="kind">send_expr</attrib>
      <symbol name="Expr_150" link="sub"/>
      <token type="exclam"/>
      <symbol name="Expr_100" link="sub"/>
    </rule>
    <copy-rule name="Expr_150"/>
  </ruleset>

  <!-- orelse, andalso -->
  <ruleset head="Expr_150">
    <rule class="expr">
      <attrib name="kind">infix_expr</attrib>
      <symbol name="Expr_160" link="sub"/>
      <token type="orelse" attr="value"/>
      <symbol name="Expr_150" link="sub"/>
    </rule>
    <copy-rule name="Expr_160"/>
  </ruleset>

  <ruleset head="Expr_160">
    <rule class="expr">
      <attrib name="kind">infix_expr</attrib>
      <symbol name="Expr_200" link="sub"/>
      <token type="andalso" attr="value"/>
      <symbol name="Expr_160" link="sub"/>
    </rule>
    <copy-rule name="Expr_200"/>
  </ruleset>

  <!-- Comparison -->
  <ruleset head="Expr_200">
    <rule class="expr">
      <attrib name="kind">infix_expr</attrib>
      <symbol name="Expr_300" link="sub"/>
      <token type="Comp_op" attr="value"/>
      <symbol name="Expr_300" link="sub"/>
    </rule>

    <copy-rule name="Expr_300"/>
  </ruleset>

  <token-class name="Comp_op">
    <token type="dbl_eq"/>
    <token type="slasheq"/>
    <token type="eqless"/>
    <token type="less"/>
    <token type="greatereq"/>
    <token type="greater"/>
    <token type="eqcoleq"/>
    <token type="eqslasheq"/>
  </token-class>

  <!-- List operators -->
  <ruleset head="Expr_300">
    <rule class="expr">
      <attrib name="kind">infix_expr</attrib>
      <symbol name="Expr_400" link="sub"/>
      <token type="List_op" attr="value"/>
      <symbol name="Expr_300" link="sub"/>
    </rule>

    <copy-rule name="Expr_400"/>
  </ruleset>

  <token-class name="List_op">
    <token type="dbl_plus"/>
    <token type="dbl_minus"/>
  </token-class>

  <!-- Addition -->
  <ruleset head="Expr_400">
    <rule class="expr">
      <attrib name="kind">infix_expr</attrib>
      <symbol name="Expr_400" link="sub"/>
      <token type="Add_op" attr="value" />
      <symbol name="Expr_500" link="sub"/>
    </rule>

    <copy-rule name="Expr_500"/>
  </ruleset>

  <token-class name="Add_op">
    <token type="plus"/>
    <token type="minus"/>
    <token type="bor"/>
    <token type="bxor"/>
    <token type="bsl"/>
    <token type="bsr"/>
    <token type="or"/>
    <token type="xor"/>
  </token-class>

  <!-- Multiplication -->
  <ruleset head="Expr_500">
    <rule class="expr">
      <attrib name="kind">infix_expr</attrib>
      <symbol name="Expr_500" link="sub"/>
      <token type="Mult_op" attr="value" />
      <symbol name="Expr_600" link="sub"/>
    </rule>

    <copy-rule name="Expr_600"/>
  </ruleset>

  <token-class name="Mult_op">
    <token type="slash"/>
    <token type="star"/>
    <token type="div"/>
    <token type="rem"/>
    <token type="band"/>
    <token type="and"/>
  </token-class>

  <!-- Prefix operators -->
  <ruleset head="Expr_600">
    <rule class="expr">
      <attrib name="kind">prefix_expr</attrib>
      <token type="Prefix_op" attr="value"/>
      <symbol name="Expr_700" link="sub"/>
    </rule>

    <copy-rule name="Expr_700"/>
  </ruleset>

  <token-class name="Prefix_op">
    <token type="plus"/>
    <token type="minus"/>
    <token type="bnot"/>
    <token type="not"/>
  </token-class>

  <!-- Function call, record expressions -->
  <ruleset head="Expr_700">
    <rule class="expr">
      <attrib name="kind">application</attrib>
      <symbol name="Expr_800" link="sub"/>
      <token type="op_paren"/>
      <optional>
        <symbol name="Expr" link="sub"/>
        <repeat>
          <token type="comma"/>
          <symbol name="Expr" link="sub"/>
        </repeat>
      </optional>
      <token type="cl_paren"/>
    </rule>

    <copy-rule name="Record_expr" />
    <copy-rule name="Expr_800"/>
  </ruleset>

  <ruleset head="Record_expr">
    <rule class="expr">
      <attrib name="kind">record_index</attrib>
      <token type="hash"/>
      <symbol name="Atom" link="sub"/>
      <token type="dot"/>
      <symbol name="Atom" link="sub"/>
    </rule>

    <rule class="expr">
      <attrib name="kind">record_access</attrib>
      <symbol name="Expr_max" link="sub"/>
      <token type="hash"/>
      <symbol name="Atom" link="sub"/>
      <token type="dot"/>
      <symbol name="Atom" link="sub"/>
    </rule>

    <rule class="expr">
      <attrib name="kind">record_expr</attrib>
      <token type="hash"/>
      <symbol name="Atom" link="sub"/>
      <token type="op_brace"/>
      <optional>
          <symbol name="Record_field" link="sub"/>        
        <repeat>
          <token type="comma"/>
          <symbol name="Record_field" link="sub"/>
        </repeat>
      </optional>
      <token type="cl_brace"/>
    </rule>

    <rule class="expr">
      <attrib name="kind">record_update</attrib>
      <symbol name="Expr_max" link="sub"/>
      <token type="hash"/>
      <symbol name="Atom" link="sub"/>
      <token type="op_brace"/>
      <optional>
          <symbol name="Record_field" link="sub"/>        
        <repeat>
          <token type="comma"/>
          <symbol name="Record_field" link="sub"/>
        </repeat>
      </optional>
      <token type="cl_brace"/>      
    </rule>
  </ruleset>

  <ruleset head="Record_field">
    <rule class="expr">
      <!-- I think this is an experimental feature -->
      <attrib name="kind">record_field</attrib>
      <symbol name="Variable" link="sub"/>
      <token type="equal"/>
      <symbol name="Expr" link="sub"/>          
    </rule>

    <rule class="expr">
      <attrib name="kind">record_field</attrib>
      <symbol name="Atom" link="sub"/>
      <token type="equal"/>
      <symbol name="Expr" link="sub"/>       
    </rule>
  </ruleset>

  <!-- Module qualifier -->
  <ruleset head="Expr_800">
    <rule class="expr">
      <attrib name="kind">module_qualifier</attrib>
      <symbol name="Expr_max" link="sub"/>          
      <token type="colon"/>
      <symbol name="Expr_max" link="sub"/>          
    </rule>

    <copy-rule name="Expr_max"/>
  </ruleset>

  <!-- Top-precedence expressions -->
  <ruleset head="Expr_max">
    <copy-rule name="Atomic"/>
    <copy-rule name="List_skel"/>
    <copy-rule name="List_compr"/>
    <copy-rule name="Binary_expr"/>
    <copy-rule name="Bin_compr"/>
    <copy-rule name="Tuple_skel"/>
    <copy-rule name="Paren_expr"/>
    <copy-rule name="Block_expr"/>
    <copy-rule name="If_expr"/>
    <copy-rule name="Case_expr"/>
    <copy-rule name="Receive_expr"/>
    <copy-rule name="Fun_expr" />
    <copy-rule name="Try_expr" />
  </ruleset>

  <!-- Variable, atom, other constants -->
  <ruleset head="AtomOrVar">
    <copy-rule name="Variable"/>
    <copy-rule name="Atom"/>
  </ruleset>

  <ruleset head="Variable">
    <rule class="expr">
      <attrib name="kind">variable</attrib>
      <token type="variable" attr="value"/>
    </rule>
  </ruleset>

  <ruleset head="Atom">
    <rule class="expr">
      <attrib name="kind">atom</attrib>
      <token type="atom" attr="value"/>
    </rule>
  </ruleset>

  <ruleset head="Integer">
    <rule class="expr">
      <attrib name="kind">integer</attrib>
      <token type="integer" attr="value"/>
    </rule>
  </ruleset>

  <ruleset head="Atomic">
    <copy-rule name="AtomOrVar"/>
    <copy-rule name="Integer"/>

    <rule class="expr">
      <attrib name="kind">char</attrib>
      <token type="char" attr="value"/>
    </rule>
      
    <rule class="expr">
      <attrib name="kind">float</attrib>
      <token type="float" attr="value"/>
    </rule>

    <rule class="expr">
      <attrib name="kind">string</attrib>
      <token type="string" attr="value"/>
      <!-- TODO collect split value -->
      <repeat>
        <token type="string"/>
      </repeat>
    </rule>
  </ruleset>

  <!-- List skeleton -->
  <ruleset head="List_skel">
    <rule class="expr">
      <attrib name="kind">list</attrib>
      <token type="op_bracket"/>
      <optional>
        <symbol name="Expr" link="sub"/>
        <repeat>
          <token type="comma"/>
          <symbol name="Expr" link="sub"/>
        </repeat>
        <optional>
          <token type="vline"/>
          <symbol name="List_tail" link="sub"/>
        </optional>
      </optional>
      <token type="cl_bracket"/>
    </rule>
  </ruleset>

  <ruleset head="List_tail">
    <rule class="expr">
      <attrib name="kind">list_tail</attrib>
      <symbol name="Expr" link="sub"/>
    </rule>
  </ruleset>

  <!-- List comprehension -->
  <ruleset head="List_compr">
    <rule class="expr">
      <attrib name="kind">list_comp</attrib>
      <token type="op_bracket"/>
      <symbol name="Expr" link="sub"/>
      <token type="dbl_vline"/>
      <symbol name="LCExpr" link ="sub"/>
      <repeat>
        <token type="comma"/>
        <symbol name="LCExpr" link ="sub"/>
      </repeat>
      <token type="cl_bracket"/>
    </rule>
  </ruleset>

  <ruleset head="LCExpr">
    <copy-rule name="Expr"/> 
    <copy-rule name="List_generator"/> 
  </ruleset>

  <ruleset head="List_generator">
    <rule class="expr">
      <attrib name="kind">list_gen</attrib>
      <symbol name="Expr" link="sub"/>
      <token type="backarrow"/>
      <symbol name="Expr" link="sub"/>
    </rule>
  </ruleset>

  <!-- Binary expression -->
  <ruleset head="Binary_expr">
    <rule class="expr">
      <attrib name="kind">binary</attrib>
      <token type="dbl_less"/>
      <optional>
        <symbol name="Bin_element" link="sub"/>
        <repeat>
          <token type="comma"/>
          <symbol name="Bin_element" link="sub"/>
        </repeat>
      </optional>
      <token type="dbl_greater"/>
    </rule>
  </ruleset>
  
  <ruleset head="Bin_element">
    <rule class="expr">
      <attrib name="kind">binary_field</attrib>
      <symbol name="Bin_base" link="sub"/>
      <optional>
        <token type="slash"/>
        <symbol name="Bit_type" link="sub"/>
        <repeat>
          <token type="minus"/>
          <symbol name="Bit_type" link="sub"/>
        </repeat>
      </optional>
    </rule>
  </ruleset>

  <ruleset head="Bin_base">
    <copy-rule name="Bit_expr"/>

    <rule class="expr">
      <attrib name="kind">size_qualifier</attrib>
      <symbol name="Bit_expr" link="sub"/>
      <token type="colon"/>
      <symbol name="Expr_max" link="sub"/>
    </rule>
  </ruleset>

  <ruleset head="Bit_expr">
    <copy-rule name="Expr_max"/> 

    <rule class="expr">
      <attrib name="kind">prefix_expr</attrib>
      <token type="Prefix_op" attr="value"/>
      <symbol name="Expr_max" link="sub"/>
    </rule>
  </ruleset>

  <ruleset head="Bit_type">
    <copy-rule name="Atom"/>

    <rule class="expr">
      <!-- TODO: better representation -->
      <attrib name="kind">tuple</attrib> <!-- nem lehet ennek kulon neve -->
      <symbol name="Atom" link="sub"/>
      <token type="colon"/>
      <token type="integer"/>
    </rule>
  </ruleset>


  <!-- Binary comprehension -->
  <!-- Experimental feature -->
  <ruleset head="Bin_compr">
    <rule class="expr">
      <attrib name="kind">bin_comp</attrib>
      <token type="dbl_less"/>
      <symbol name="Binary_expr" link ="sub"/>    
      <token type="dbl_vline"/>
      <symbol name="BCExpr" link ="sub"/>
      <repeat>
        <token type="comma"/>
        <symbol name="BCExpr" link="sub"/>
      </repeat>
      <token type="dbl_greater"/>
    </rule>
  </ruleset>

  <ruleset head="BCExpr">
    <copy-rule name="Expr"/> 
    <copy-rule name="Bin_generator"/> 
  </ruleset>

  <ruleset head="Bin_generator">
    <rule class="expr">
      <attrib name="kind">list_gen</attrib>
      <symbol name="Expr" link="sub"/>
      <token type="backbinarrow"/>
      <symbol name="Expr" link="sub"/>
    </rule>
  </ruleset>

  <!-- Tuple skeleton -->
  <ruleset head="Tuple_skel">
    <rule class="expr">
      <attrib name="kind">tuple</attrib>
      <token type="op_brace"/>
      <optional>
        <symbol name="Expr" link="sub"/>
        <repeat>
          <token type="comma"/>
          <symbol name="Expr" link="sub"/>
        </repeat>
      </optional>
      <token type="cl_brace"/>
    </rule>
  </ruleset>

  <!-- Parentheses -->
  <ruleset head="Paren_expr">
    <rule class="expr">
      <attrib name="kind">parenthesis</attrib>
      <token type="op_paren"/>
      <symbol name="Expr" link="sub"/>
      <token type="cl_paren"/>
    </rule>
  </ruleset>

  <!-- begin ... end -->
  <ruleset head="Block_expr">
    <rule class="expr">
      <attrib name="kind">block_expr</attrib>
      <token type="begin"/>
      <symbol name="Block_clause" link="exprcl"/>
      <token type="end"/>
    </rule>
  </ruleset>

  <ruleset head="Block_clause">
    <rule class="clause">
      <attrib name="type">block</attrib>
      <symbol name="Expr" link="body"/>
      <repeat>
        <token type="comma"/>
        <symbol name="Expr" link="body"/>
      </repeat>
    </rule>
  </ruleset>


  <!-- if -->
  <ruleset head="If_expr">
    <rule class="expr">
      <attrib name="kind">if_expr</attrib>
      <token type="if"/>
      <symbol name="If_clause" link="exprcl"/>
        <repeat>
          <token type="semicol"/>
          <symbol name="If_clause" link="exprcl"/>
        </repeat>
      <token type="end"/>
    </rule>
  </ruleset>

  <ruleset head="If_clause">
    <rule class="clause">
      <attrib name="type">branch</attrib>
      <symbol name="Guard_seq" link="guard"/>
      <token type="arrow"/>
      <symbol name="Expr" link="body"/>
      <repeat>
        <token type="comma"/>
        <symbol name="Expr" link="body"/>
      </repeat>
    </rule>
  </ruleset>

  <!-- case -->
  <ruleset head="Case_expr">
    <rule class="expr">
      <attrib name="kind">case_expr</attrib>
      <token type="case"/>
      <symbol name="Case_block" link="exprcl"/>
      <token type="of"/>
      <symbol name="Case_clause" link="exprcl"/>
        <repeat>
          <token type="semicol"/>
          <symbol name="Case_clause" link="exprcl"/>
        </repeat>
      <token type="end"/>
    </rule>
  </ruleset>

  <ruleset head="Case_block">
    <rule class="clause">
      <attrib name="type">block</attrib>
      <symbol name="Expr" link="body" />
    </rule>
  </ruleset>

  <ruleset head="Case_clause">
    <rule class="clause">
      <attrib name="type">branch</attrib>
        <symbol name="Expr" link="pattern"/>
      <optional>
        <token type="when"/>
        <symbol name="Guard_seq" link="guard"/>
      </optional>
      <token type="arrow"/>
      <symbol name="Expr" link="body"/>
      <repeat>
        <token type="comma"/>
        <symbol name="Expr" link="body"/>
      </repeat>
    </rule>
  </ruleset>

  <!-- receive -->
  <ruleset head="Receive_expr">
    <rule class="expr">
      <attrib name="kind">receive_expr</attrib>
      <token type="receive"/>      
      <optional>
        <symbol name="Case_clause" link="exprcl"/>
        <repeat>
          <token type="semicol"/>
          <symbol name="Case_clause" link="exprcl"/>
        </repeat>
      </optional>
      <optional>
        <token type="after"/>
        <symbol name="After_clause" link="aftercl"/>
      </optional>
      <token type="end"/>
    </rule>
  </ruleset>
    
  <ruleset head="After_clause">
    <rule class="clause">
      <attrib name="type">branch</attrib>
      <symbol name="Expr" link="tmout"/>
      <token type="arrow"/>
      <symbol name="Expr" link="body"/>
      <repeat>
        <token type="comma"/>
        <symbol name="Expr" link="body"/>
      </repeat>
    </rule>
  </ruleset>

  <!-- fun -->
  <ruleset head="Fun_expr">
    <rule class="expr">
      <attrib name="kind">fun_expr</attrib>
      <token type="fun"/>      
      <symbol name="Funexpr_clause" link="exprcl"/>
      <repeat>
        <token type="semicol"/>
        <symbol name="Funexpr_clause" link="exprcl"/>
      </repeat>
      <token type="end"/>
    </rule>

    <rule class="expr">
      <attrib name="kind">fun_expr</attrib>
      <token type="fun"/>
      <symbol name="Arity_qualifier" link="sub"/>
    </rule>
  </ruleset>

  <ruleset head="Arity_qualifier">
    <rule class="expr">
      <attrib name="kind">arity_qualifier</attrib>
      <symbol name="Atom" link="sub"/>
      <token type="slash"/>
      <symbol name="Integer" link="sub"/>
    </rule>

    <rule class="expr">
      <attrib name="kind">arity_qualifier</attrib>
      <symbol name="Module_qualifier" link="sub"/>
      <token type="slash"/>
      <symbol name="Integer" link="sub"/>
    </rule>
  </ruleset>

  <ruleset head="Module_qualifier">
    <rule class="expr">
      <attrib name="kind">module_qualifier</attrib>
      <symbol name="Atom" link="sub"/>
      <token type="colon"/>
      <symbol name="Atom" link="sub"/>
    </rule>
  </ruleset>

  <ruleset head="Funexpr_clause">
    <rule class="clause">
      <attrib name="type">funcl</attrib>
      <token type="op_paren"/>
      <optional>
        <symbol name="Expr" link="pattern"/>
        <repeat>
          <token type="comma"/>
          <symbol name="Expr" link="pattern"/>
        </repeat>
      </optional>
      <token type="cl_paren"/>
      <optional>
        <token type="when"/>
        <symbol name="Guard_seq" link="guard"/>
      </optional>
      <token type="arrow"/>
      <symbol name="Expr" link="body"/>
      <repeat>
        <token type="comma"/>
        <symbol name="Expr" link="body"/>
      </repeat>
    </rule>
  </ruleset>

  <!-- try -->
  <ruleset head="Try_expr">
    <rule class="expr">
      <attrib name="kind">try_expr</attrib>
      <token type="try"/>      
      <symbol name="Block_clause" link="exprcl"/>
      <optional>
        <token type="of"/>
        <symbol name="Case_clause" link="exprcl"/>
        <repeat>
          <token type="semicol"/>
          <symbol name="Case_clause" link="exprcl"/>
        </repeat>
      </optional>
      <optional>
        <token type="catch"/>
        <symbol name="Handler_clause" link="handlercl"/>
        <repeat>
          <token type="semicol"/>
          <symbol name="Handler_clause" link="handlercl"/>
        </repeat>
      </optional>
      <optional>
        <token type="after"/>
        <symbol name="Block_clause" link="aftercl"/>
      </optional>
      <token type="end"/>
    </rule>
  </ruleset>

  <ruleset head="Handler_clause">
    <rule class="clause">
      <attrib name="type">branch</attrib>
      <symbol name="Exception" link="pattern"/>
      <optional>
        <token type="when"/>
        <symbol name="Guard_seq" link="guard"/>
      </optional>
      <token type="arrow"/>
      <symbol name="Expr" link="body"/>
      <repeat>
        <token type="comma"/>
        <symbol name="Expr" link="body"/>
      </repeat>
    </rule>
  </ruleset>

  <ruleset head="Exception">
    <copy-rule name="Expr"/>
    <copy-rule name="Class_qualifier"/>
  </ruleset>

  <ruleset head="Class_qualifier">
    <rule class="expr">
      <attrib name="kind">class_qualifier</attrib>
      <symbol name="Atom" link="sub"/>
      <token type="colon"/>
      <symbol name="Expr" link="sub"/>
    </rule>

    <rule class="expr">
      <!-- Is this officially supported? -->
      <attrib name="kind">class_qualifier</attrib>
      <symbol name="Variable" link="sub"/>
      <token type="colon"/>
      <symbol name="Expr" link="sub"/>
    </rule>
  </ruleset>


<!-- Lexical rules -->

  
  <!-- Textual keywords -->
  <keyword name="after"  >after</keyword>
  <keyword name="and"    >and</keyword>
  <keyword name="andalso">andalso</keyword>
  <keyword name="band"   >band</keyword>
  <keyword name="begin"  >begin</keyword>
  <keyword name="bnot"   >bnot</keyword>
  <keyword name="bor"    >bor</keyword>
  <keyword name="bsl"    >bsl</keyword>
  <keyword name="bsr"    >bsr</keyword>
  <keyword name="bxor"   >bxor</keyword>
  <keyword name="case"   >case</keyword>
  <keyword name="catch"  >catch</keyword>
  <keyword name="div"    >div</keyword>
  <keyword name="end"    >end</keyword>
  <keyword name="fun"    >fun</keyword>
  <keyword name="if"     >if</keyword>  
  <keyword name="not"    >not</keyword>
  <keyword name="of"     >of</keyword>
  <keyword name="or"     >or</keyword>
  <keyword name="orelse" >orelse</keyword>
  <keyword name="receive">receive</keyword>
  <keyword name="rem"    >rem</keyword>
  <keyword name="try"    >try</keyword>
  <keyword name="when"   >when</keyword>
  <keyword name="xor"    >xor</keyword>

  <!-- Separators -->
  <keyword name="op_paren"   >(</keyword>
  <keyword name="cl_paren"   >)</keyword>
  <keyword name="op_brace"   >{</keyword>
  <keyword name="cl_brace"   >}</keyword>
  <keyword name="op_bracket" >[</keyword>
  <keyword name="cl_bracket" >]</keyword>
  <keyword name="dbl_less"   >&lt;&lt;</keyword>
  <keyword name="dbl_greater">&gt;&gt;</keyword>
  <keyword name="comma"      >,</keyword>
  <keyword name="semicol"    >;</keyword>
  <keyword name="colon"      >:</keyword>
  <keyword name="arrow"      >-&gt;</keyword>
  <keyword name="vline"      >|</keyword>
  <keyword name="dbl_vline"  >||</keyword>
  <keyword name="hash"       >#</keyword>

  <!-- Operators -->
  <keyword name="equal"      >=</keyword>
  <keyword name="plus"       >+</keyword>
  <keyword name="minus"      >-</keyword>
  <keyword name="star"       >*</keyword>
  <keyword name="slash"      >/</keyword>
  <keyword name="exclam"     >!</keyword>
  <keyword name="dbl_plus"   >++</keyword>
  <keyword name="dbl_minus"  >--</keyword>
  <keyword name="dbl_eq"     >==</keyword>
  <keyword name="slasheq"    >/=</keyword>
  <keyword name="eqcoleq"    >=:=</keyword>
  <keyword name="eqslasheq"  >=/=</keyword>
  <keyword name="less"       >&lt;</keyword>
  <keyword name="greater"    >&gt;</keyword>
  <keyword name="eqless"     >=&lt;</keyword>
  <keyword name="greatereq"  >&gt;=</keyword>
  <keyword name="backarrow"  >&lt;-</keyword>
  <keyword name="questionm"  >?</keyword>

  <keyword name="backbinarrow">&lt;=</keyword>

  <keyword-prefix>
    <match name="PRE"/>
  </keyword-prefix>

  <keyword-postfix>
    <match name="POST"/>
  </keyword-postfix>

  <lexical name="dot">
    <match name="PRE"/>
    <text>.</text>
  </lexical>

  <lexical name="stop">
    <match name="PRE"/>
    <text>.</text>
    <match name="POSTSTOP"/>
  </lexical>

  <lexical name="atom">
    <match name="PRE"/>
    <branches>
      <br>
        <match name="Lower"/>
        <rep>
          <match name="Namechar"/>
        </rep>
      </br>
      <br>
        <text>'</text>
        <rep>
          <branches>
            <br><chars-but><char code="10" />\'</chars-but></br>
            <br><match name="Escape" /></br>
          </branches>
        </rep>
        <text>'</text>
      </br>
    </branches>
    <match name="POST"/>
  </lexical>

  <lexical name="variable">
    <match name="PRE"/>
    <branches>
      <br><match name="Upper" /></br>
      <br><text>_</text></br>
    </branches>
    <rep>
      <match name="Namechar" />
    </rep>
    <match name="POST"/>
  </lexical>

  <lexical name="string">
    <match name="PRE"/>
    <text>&quot;</text>
    <rep>
      <branches>
        <!-- was: <chars-but>&quot;\<char code="10"/></chars-but>
	     but: it can contain line ends! -->
        <br><chars-but>&quot;\</chars-but></br>
        <br><match name="Escape"/></br>
      </branches>
    </rep>
    <text>&quot;</text>
    <match name="POST"/>
  </lexical>

  <lexical name="integer">
    <match name="PRE"/>
    <branches>
      <br>
        <opt>
          <chars-of><range><from>2</from><to>9</to></range></chars-of>
          <text>#</text>
        </opt>
        <match name="Digit"/>
        <rep>
          <match name="Digit"/>
        </rep>
      </br>
      <br>
        <chars-of><range><from>1</from><to>3</to></range></chars-of>
        <chars-of><range><from>0</from><to>9</to></range></chars-of>
        <text>#</text>
        <chars-of>
          <range><from>0</from><to>9</to></range>
          <range><from>a</from><to>z</to></range>
          <range><from>A</from><to>Z</to></range>
        </chars-of>
        <rep>
          <chars-of>
            <range><from>0</from><to>9</to></range>
            <range><from>a</from><to>z</to></range>
            <range><from>A</from><to>Z</to></range>
          </chars-of>
        </rep>
      </br>
    </branches>
    <match name="POST"/>
  </lexical>

  <lexical name="float">
    <match name="PRE"/>
    <match name="Digit"/>
    <rep>
      <match name="Digit"/>
    </rep>
    <text>.</text>
    <match name="Digit"/>
    <rep>
      <match name="Digit"/>
    </rep>    
    <match name="POST"/>
  </lexical>

  <lexical name="char">
    <match name="PRE"/>
    <text>$</text>
    <branches>
      <br><chars-but>\<char code="10"></char></chars-but></br>
      <br><match name="Escape" /></br>
    </branches>
    <match name="POST"/>
  </lexical>

  <pattern name="Upper">
    <chars-of>
      <range><from>A</from><to>Z</to></range>
      <range><from><char code="192"/></from><to><char code="214"/></to></range>
      <range><from><char code="216"/></from><to><char code="222"/></to></range>
    </chars-of>
  </pattern>

  <pattern name="Lower">
    <chars-of>
      <range><from>a</from><to>z</to></range>
      <range><from><char code="223"/></from><to><char code="246"/></to></range>
      <range><from><char code="248"/></from><to><char code="255"/></to></range>
    </chars-of>
  </pattern>
  
  <pattern name="Digit">
    <chars-of><range><from>0</from><to>9</to></range></chars-of>
  </pattern>

  <pattern name="Octal">
    <chars-of><range><from>0</from><to>7</to></range></chars-of>
  </pattern>
  
  <pattern name="Escape">
    <text>\</text>
    <branches>
      <br>
        <chars-but><range><from>0</from><to>7</to></range></chars-but>
      </br>
      <br>
        <match name="Octal"/>
        <opt>
          <match name="Octal"/>
          <opt><match name="Octal"/></opt>
        </opt>
      </br>
      <br>
        <text>^</text>
        <chars-of><range><from>A</from><to>Z</to></range></chars-of>
      </br>
    </branches>
  </pattern>

  <pattern name="Namechar">
    <branches>
      <br><match name="Digit" /></br>
      <br><match name="Lower" /></br>
      <br><match name="Upper" /></br>
      <br><chars-of>_@</chars-of></br>
    </branches>
  </pattern>

  <pattern name="Comment">
    <text>%</text>
    <rep>
      <chars-but><char code="10"/></chars-but>
    </rep>
    <text><char code="10"/></text>
    <opt><text><char code="13"></char></text></opt>
  </pattern>

  <pattern name="WS">
    <branches>
      <br><match name="Comment"/></br>
      <br>
        <chars-of>
          <char code="32"/>
          <char code="9"/>
          <char code="10"/>
          <char code="13"/>
        </chars-of>
      </br>
    </branches>
  </pattern>

  <pattern name="PRE">
    <rep><match name="WS"/></rep>
  </pattern>

  <pattern name="POSTSTOP">
    <rep><match name="WS"/></rep>
  </pattern>

  <pattern name="POST">
    <opt>
      <rep>
        <chars-of>
          <char code="9"/>
          <char code="32"/>
        </chars-of>
      </rep>
      <branches>
        <br><match name="Comment"/></br>
        <br><text><char code="10"/></text>
          <opt><text><char code="13"></char></text></opt>
        </br>
      </branches>
    </opt>
  </pattern>

</erlang-syntax>
